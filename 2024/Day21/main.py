from functools import cache
from collections import deque

numpad = [
    ["7", "8", "9"],
    ["4", "5", "6"],
    ["1", "2", "3"],
    [None, "0", "A"]
]

dirpad = [
    [None, "^", "A"],
    ["<", "v", ">"]
]


def find_char(grid, target):
    rows, cols = len(grid), len(grid[0])

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == target:
                return (i, j)

    raise ValueError("char not found")


@cache
def get_shortest_paths(pad, start, end):

    if start == end: return ["A"]

    pad = numpad if pad == "numpad" else dirpad
    sr, sc = find_char(pad, start)
    queue = deque([(sr, sc, "")])
    optimalSolutions = set()
    shortest = float("inf")
    try:
        while queue:
            cr, cc, cm = queue.popleft()
            newPositions = [(cr - 1, cc, cm + "^"), (cr + 1, cc, cm + "v"), (cr, cc - 1, cm + "<"),
                            (cr, cc + 1, cm + ">")]
            for nr, nc, nm in newPositions:
                if not (0 <= nr < len(pad) and 0 <= nc < len(pad[nr])): continue
                if pad[nr][nc] is None: continue

                if pad[nr][nc] == end:
                    if len(nm) > shortest:
                        raise ValueError("all found")
                    shortest = len(nm)
                    optimalSolutions.add(nm + "A")
                    continue
                queue.append((nr, nc, nm))
    except ValueError:
        return optimalSolutions
    if len(optimalSolutions) == 0:
        raise ValueError("no solutions")
    return optimalSolutions


@cache
def get_length(a, b, n):
    paths = get_shortest_paths("dirpad", a, b)
    x = next(iter(paths))
    if n == 0: return len(x)

    opt = float("inf")
    for p in paths:
        l = 0
        for i in range(-1, len(p) - 1):
            from_ = p[i]
            to_ = p[i + 1]
            r = get_length(from_, to_, n - 1)
            l += r
        opt = min(opt, l)
    return opt


# this method is generated by ai
def cartesian_product(arrays):
    if not arrays:
        return []

    results = [[x] for x in arrays[0]]

    for array in arrays[1:]:
        new_results = []
        for result in results:
            for item in array:
                new_results.append(result + [item])
        results = new_results

    return ["".join(result) for result in results]

inp = input("which part: ")
part  = 1 if inp == "1" else 24
sum_all = 0
for line in [line.strip("\n") for line in open("21.txt")]:

    paths_list = []
    for i in range(-1, len(line) - 1):
        paths_list.append(get_shortest_paths("numpad", line[i], line[i + 1]))
    r = cartesian_product(paths_list)

    s = 0
    opt = float("inf")
    for p in r:
        r = 0
        for i in range(-1, len(p) - 1):
            from_ = p[i]
            to_ = p[i + 1]
            r += get_length(from_, to_, part)
        opt = min(opt, r)
    s += opt

    numeric_value = int(line[:-1])

    sum_all += s * numeric_value
print(sum_all)
